%% Start of the program
clc
clear

fprintf("Welcome to use this mosaic processing program!\n\n")


%% read the image

fileName=input("Please enter the file name (remember to attach the suffix of the image file and single quotation marks): ");
fprintf("\n")
[image]=readimage(fileName); % This function is used to get the image file name and transfer the variable type.
[original_image]=readimage(fileName); % original_image is an array used to fill in the rest of parts (out of mosaic)


%% know the size of the image

[rows,cols]=size(image); % col is generated by []=size(); Therefore, it is the channels of column

if size(original_image,3)==3 % This means the image is RGB image. We have to divide the column number by 3 because there are three channels.
    fprintf("The size of this image is %d * %d (pixels).\n\n",rows,cols/3);
else % This means the image is greyscale image
    fprintf("The size of this image is %d * %d (pixels).\n\n",rows,cols);
end


%% processing 
consecutive=false;
processing=1;
times=1; % trigger a process for the non-first processing (modifying image pixel type)
while ~consecutive
    switch processing
        case 1
            %% set the working spaces
            if times==1
                left_up_row=50;
                right_down_row=rows-50;
                if size(original_image,3)==3 % This means the image is RGB image.
                    left_up_col=50;
                    right_down_col=(cols/3)-50;
                else
                    left_up_col=50;
                    right_down_col=cols-50;
                end
            end
                    
           
            %% visualise the working spaces and adjust working spaces
            
            flag=false;
            
            while ~flag
                
                v_image=[]; % initialise
                v_show_image=[];
                
                if times==1 % assign values to v_image and v_show_image
                    if size(original_image,3)==3 % This means the image is RGB image.
                        for i=1:rows % transforming data type
                            for j=1:cols/3
                                for h=1:3
                                    v_image(i,j,h)=image(i,j,h)/255;
                                    v_show_image(i,j,h)=image(i,j,h)/255;
                                end
                            end
                        end
                    else % This means the image is grayscale image.
                        for i=1:rows % transforming data type
                            for j=1:cols
                                v_image(i,j,1)=image(i,j,1)/255;
                                v_show_image(i,j,1)=image(i,j,1)/255;
                            end
                        end
                    end
                else
                    if size(original_image,3)==3 % This means the image is RGB image.
                        for i=1:rows % transforming data type
                            for j=1:cols % in the first time, col has already been divided by 3
                                for h=1:3
                                    v_image(i,j,h)=image(i,j,h);
                                    v_show_image(i,j,h)=image(i,j,h);
                                end
                            end
                        end
                    else % This means the image is grayscale image.
                        for i=1:rows % transforming data type
                            for j=1:cols
                                v_image(i,j,1)=image(i,j,1);
                                v_show_image(i,j,1)=image(i,j,1);
                            end
                        end
                    end
                end
                
                
                if size(original_image,3)==3 % This means this image is RGB image.
                    
                    if times==1
                        for i=1:rows % Form white area
                            for j=1:cols/3
                                if i>=left_up_row && i<=right_down_row && j>=left_up_col && j<=right_down_col
                                    for h=1:3
                                        v_show_image(i,j,h)=0.9;
                                    end
                                end
                            end
                        end
                        for i=1:rows % fill inside of the white rectangular
                            for j=1:cols/3
                                if i>=left_up_row+5 && i<=right_down_row-5 && j>=left_up_col+5 && j<=right_down_col-5
                                    for h=1:3
                                        v_show_image(i,j,h)=v_image(i,j,h);
                                    end
                                end
                            end
                        end
                    else
                        for i=1:rows % Form white area
                            for j=1:cols
                                if i>=left_up_row && i<=right_down_row && j>=left_up_col && j<=right_down_col
                                    for h=1:3
                                        v_show_image(i,j,h)=0.9;
                                    end
                                end
                            end
                        end
                        for i=1:rows % fill inside of the white rectangular
                            for j=1:cols
                                if i>=left_up_row+5 && i<=right_down_row-5 && j>=left_up_col+5 && j<=right_down_col-5
                                    for h=1:3
                                        v_show_image(i,j,h)=v_image(i,j,h);
                                    end
                                end
                            end
                        end
                    end
                           
                else % This means the image is grayscale image.
                    for i=1:rows  % Form white area
                        for j=1:cols
                            if i>=left_up_row && i<=right_down_row && j>=left_up_col && j<=right_down_col
                                v_show_image(i,j,1)=1;
                            end
                        end
                    end
                    for i=1:rows % fill inside of the white rectangular
                        for j=1:cols
                            if i>=left_up_row+5 && i<=right_down_row-5 && j>=left_up_col+5 && j<=right_down_col-5
                                v_show_image(i,j,1)=v_image(i,j,1);
                            end
                        end
                    end
                end
                
                imshow(v_show_image); % visualise
                
                fprintf("How do you want to adjust this working area?\n")
                fprintf("Adjust upper row boundary ---> 1\n")
                fprintf("Adjust downward row boundary ---> 2\n")
                fprintf("Adjust left column boundary ---> 3\n")
                fprintf("Adjust right column boundary ---> 4\n")
                fprintf("This is okey! ---> 5\n")
                fprintf("Check the size of the image ---> 6\n")
                fprintf("\n")
                answer=input("Which operation do you want (enter a number): ");
                
                switch answer
                    case 1
                        fprintf("Your previous upper row boundary is %d.\n",left_up_row);
                        left_up_row=input("Please enter the upper row boundary of working spaces: ");
                    case 2
                        fprintf("Your previous downward row boundary is %d.\n",right_down_row);
                        right_down_row=input("Please enter the downward row boundary of working spaces: ");
                    case 3
                        fprintf("Your previous left column boundary is %d.\n",left_up_col);
                        left_up_col=input("Please enter the left column boundary of working spaces: ");
                    case 4
                        fprintf("Your previous right column boundary is %d.\n",right_down_col);
                        right_down_col=input("Please enter the right column boundary of working spaces: ");
                    case 5
                        flag=true;
                    case 6
                        if size(original_image,3)==3 % This means the image is RGB image. We have to divide the column number by 3 because there are three channels.
                            fprintf("The size of this image is %d * %d (pixels).\n\n",rows,cols/3);
                        else % This means the image is greyscale image
                            fprintf("The size of this image is %d * %d (pixels).\n\n2",rows,cols);
                        end
                end
            end
            
            ms=input("Please enter your mosaic size (pixels): ");
            
            fprintf("If the image size is big, please hold on a second : )\n\n")
            
            
            %% decide how many pixel group rows should be created
            if mod(rows,ms)==0
                rows_groups=rows/ms;
            else
                rows_groups=floor(rows/ms);
            end
            
            %% decide how many pixel group columns should be created
            
            if size(original_image,3)==3 % This means the image is RGB image.
                if times==1
                    cols=cols/3;
                end
                if mod(cols,ms)==0
                    cols_groups=cols/ms;
                else
                    cols_groups=floor(cols/ms);
                end
            else % This means the image is grayscale image.
                if mod(cols,ms)==0
                    cols_groups=cols/ms;
                else
                    cols_groups=floor(cols/ms);
                end
            end
            
            
            
            %% find the average value of each pixel group and replace every pixel groups by the average pixel value (main part of an image)
            
            for i=1:ms:ms*(rows_groups) % row index of the start of each group
                for j=1:ms:ms*(cols_groups) %column index of the start of each group
                    sum_r=0; %initialise the sum of Red
                    sum_g=0; %initialise the sum of Green
                    sum_b=0; %initialise the sum of Blue
                    %% calculate the average pixel value of a pixel group
                    for r=1:ms
                        for s=1:ms
                            sum_r=sum_r+image(i+r-1,j+s-1,1);
                            if size(original_image,3)==3 % This means the image is RGB image. We have to divide the column number by 3 because there are three channels.
                                sum_g=sum_g+image(i+r-1,j+s-1,2);
                                sum_b=sum_b+image(i+r-1,j+s-1,3);
                            end
                        end
                    end
                    
                    if times==1
                        ep_r=sum_r/(ms*ms)/255;
                        if size(original_image,3)==3 % This means the image is RGB image.
                            ep_g=sum_g/(ms*ms)/255;
                            ep_b=sum_b/(ms*ms)/255;
                        end
                    else
                        ep_r=sum_r/(ms*ms);
                        if size(original_image,3)==3 % This means the image is RGB image.
                            ep_g=sum_g/(ms*ms);
                            ep_b=sum_b/(ms*ms);
                        end
                    end
                        
                    %% replace every value in a pixel group by the calculated average value
                    for ci=i:i+ms-1
                        for cj=j:j+ms-1
                            image(ci,cj,1)=ep_r;
                            if size(original_image,3)==3 % This means the image is RGB image.
                                image(ci,cj,2)=ep_g;
                                image(ci,cj,3)=ep_b;
                            end
                        end
                    end
                end
            end
            
            
            %% deal with margin mosaic (last row / last column / last rectangular pixel group)
            
            %% deal with the last row of mosaic
            last_row=(ms*rows_groups)+1; % last row index
            if last_row<=rows % we need to handle the last row of mosaic
                for j=1:ms:ms*(cols_groups) %column index of the start of each group
                    sum_r=0; %initialise the sum of Red
                    sum_g=0; %initialise the sum of Green
                    sum_b=0; %initialise the sum of Blue
                    %% calculate the average pixel value of a pixel group
                    for r=last_row:rows
                        for s=1:ms
                            sum_r=sum_r+image(r,j+s-1,1);
                            if size(original_image,3)==3 % This means the image is RGB image.
                                sum_g=sum_g+image(r,j+s-1,2);
                                sum_b=sum_b+image(r,j+s-1,3);
                            end
                        end
                    end
                    
                    if times==1
                        ep_r=sum_r/((rows-last_row+1)*ms)/255;
                        if size(original_image,3)==3 % This means the image is RGB image.
                            ep_g=sum_g/((rows-last_row+1)*ms)/255;
                            ep_b=sum_b/((rows-last_row+1)*ms)/255;
                        end
                    else
                        ep_r=sum_r/((rows-last_row+1)*ms);
                        if size(original_image,3)==3 % This means the image is RGB image.
                            ep_g=sum_g/((rows-last_row+1)*ms);
                            ep_b=sum_b/((rows-last_row+1)*ms);
                        end
                    end
                        
                    %% replace every value in a pixel group by the calculated average value
                    for ci=last_row:rows
                        for cj=1:ms
                            image(ci,cj+j-1,1)=ep_r;
                            if size(original_image,3)==3 % This means the image is RGB image.
                                image(ci,cj+j-1,2)=ep_g;
                                image(ci,cj+j-1,3)=ep_b;
                            end
                        end
                    end
                end
                %     disp('The program handled the last row for mosaic');
            end
            
            
            %% deal with the last column of mosaic
            last_col=(ms*cols_groups)+1; % last column index
            if last_col<=cols % we need to handle the last column of mosaic
                for i=1:ms:ms*(rows_groups) %row index of the start of each group
                    sum_r=0; %initialise the sum of Red
                    sum_g=0; %initialise the sum of Green
                    sum_b=0; %initialise the sum of Blue
                    %% calculate the average pixel value of a pixel group
                    for c=last_col:cols
                        for r=1:ms
                            sum_r=sum_r+image(r+i-1,c,1);
                            if size(original_image,3)==3 % This means the image is RGB image.
                                sum_g=sum_g+image(r+i-1,c,2);
                                sum_b=sum_b+image(r+i-1,c,3);
                            end
                        end
                    end
                    
                    if times==1
                        ep_r=sum_r/((cols-last_col+1)*ms)/255;
                        if size(original_image,3)==3 % This means the image is RGB image.
                            ep_g=sum_g/((cols-last_col+1)*ms)/255;
                            ep_b=sum_b/((cols-last_col+1)*ms)/255;
                        end
                    else
                        ep_r=sum_r/((cols-last_col+1)*ms);
                        if size(original_image,3)==3 % This means the image is RGB image.
                            ep_g=sum_g/((cols-last_col+1)*ms);
                            ep_b=sum_b/((cols-last_col+1)*ms);
                        end
                    end
                        
                    %% replace every value in a pixel group by the calculated average value
                    for cj=last_col:cols
                        for ci=1:ms
                            image(ci+i-1,cj,1)=ep_r;
                            if size(original_image,3)==3 % This means the image is RGB image.
                                image(ci+i-1,cj,2)=ep_g;
                                image(ci+i-1,cj,3)=ep_b;
                            end
                        end
                    end
                end
                %     disp('The program handled the last column for mosaic');
            end
            
            
            %% deal with last rectangular pixel group
            sum=0; % initialise the sum above
            %decide the stating point
            if last_row<=rows && last_col<=cols
                sum_r=0; %initialise the sum of Red
                sum_g=0; %initialise the sum of Green
                sum_b=0; %initialise the sum of Blue
                for i=last_row:rows
                    %% calculate the average pixel value of a pixel group
                    for j=last_col:cols
                        sum_r=sum_r+image(i,j,1);
                        if size(original_image,3)==3 % This means the image is RGB image.
                            sum_g=sum_g+image(i,j,2);
                            sum_b=sum_b+image(i,j,3);
                        end
                    end
                end
                
                if times==1
                    ep_r=sum_r/((rows-last_row+1)*(cols-last_col+1))/255;
                    if size(original_image,3)==3 % This means the image is RGB image.
                        ep_g=sum_g/((rows-last_row+1)*(cols-last_col+1))/255;
                        ep_b=sum_b/((rows-last_row+1)*(cols-last_col+1))/255;
                    end
                else
                    ep_r=sum_r/((rows-last_row+1)*(cols-last_col+1));
                    if size(original_image,3)==3 % This means the image is RGB image.
                        ep_g=sum_g/((rows-last_row+1)*(cols-last_col+1));
                        ep_b=sum_b/((rows-last_row+1)*(cols-last_col+1));
                    end
                end
                
                %% replace every value in a pixel group by the calculated average value
                for i=last_row:rows
                    for j=last_col:cols
                        image(i,j,1)=ep_r;
                        if size(original_image,3)==3 % This means the image is RGB image.
                            image(i,j,2)=ep_g;
                            image(i,j,3)=ep_b;
                        end
                    end
                end
                %     disp('The program handled the last rectangular pixel group for mosaic')
            end
          
            
            %% fill in other parts of the image
            for r=1:size(image,1)
                for c=1:size(image,2)
                    if (r<=left_up_row) || (r>=right_down_row)
                        if times==1
                            image(r,c,1)=original_image(r,c,1)/255;
                            if size(original_image,3)==3 % This means the image is RGB image
                                image(r,c,2)=original_image(r,c,2)/255;
                                image(r,c,3)=original_image(r,c,3)/255;
                            end
                        else
                            image(r,c,1)=original_image(r,c,1);
                            if size(original_image,3)==3 % This means the image is RGB image
                                image(r,c,2)=original_image(r,c,2);
                                image(r,c,3)=original_image(r,c,3);
                            end
                        end
                    end
                end
            end
            
            for r=1:size(image,1)
                for c=1:size(image,2)
                    if (c<=left_up_col)  || (c>=right_down_col)
                       if times==1 
                            image(r,c,1)=original_image(r,c,1)/255;
                            if size(original_image,3)==3 % This means the image is RGB image
                                image(r,c,2)=original_image(r,c,2)/255;
                                image(r,c,3)=original_image(r,c,3)/255;
                            end
                       else
                           image(r,c,1)=original_image(r,c,1);
                            if size(original_image,3)==3 % This means the image is RGB image
                                image(r,c,2)=original_image(r,c,2);
                                image(r,c,3)=original_image(r,c,3);
                            end
                       end
                    end
                end
            end
            
            %% show the outcome image
            imshow(image)
            
            
            %% modify original image (to be prepared for the next processing)
            if size(original_image,3)==3 % This means the image is RGB image.
                for i=1:rows % transforming data type
                    for j=1:cols
                        for h=1:3
                            original_image(i,j,h)=image(i,j,h);
                        end
                    end
                end
            else % This means the image is grayscale image.
                for i=1:rows % transforming data type
                    for j=1:cols
                        original_image(i,j,1)=image(i,j,1);
                    end
                end
            end
                            
                    
            %% consecutive processing
            fprintf("How do you want to adjust this working area?\n")
            fprintf("Continue to put mosaic ---> 1\n");
            fprintf("End the program ---> 2\n");
            processing=input("Which operation do you want (enter a number):");
            fprintf("\n")
            times=times+1;
        case 2
            consecutive=true;
            fprintf("Thanks for using this program!\n")
            fprintf("-------------------------------------------\n")
            fprintf("The developer of this program is Jiajun Yu.\n")
            fprintf("This is Jiajun Yu's design for MATLAB program.\n")
            fprintf("ALL RIGHT RESERVED!\n")
    end
end
            
